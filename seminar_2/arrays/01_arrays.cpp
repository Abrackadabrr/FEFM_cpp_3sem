#include <iostream>

// корректно == компилятор не будет ругаться

int main() {
    // корректно инициализированный массив
    int a[3] = {23, 7, 3};

    std::cout << "Массив a" << std::endl;
    for (int i = 0; i < 3; i++) std::cout << a[i] << ' ';
    std::cout << std::endl;


    // это корректно инициализированный массив
    // скорее всего b[3] будет нулем, но может и не быть им, так как явно не был инициализирован
    int b[4] = {3, 4, 18};
    
    std::cout << "Массив b" << std::endl;
    for (int i = 0; i < 4; i++) std::cout << b[i] << ' ';
    std::cout << std::endl;

//    а вот так делать нельзя, ошибка компиляции
//    int c[2] = {2, 3, 4, 5};

    // С-style строки задаются массивом с терминальным символом в конце (символ конца строки) '\0'
    char string[] = {'H', 'e', 'l', 'l', 'o', '\0'};
    std::cout << string << std::endl;

    // а если забыть терминальный символ, то
    char string_1[] = {'N', 'o', ' ', 'e', 'n', 'd', ' ', 's', 'y', 'm', 'b', 'o', 'l'};
    std::cout << string_1;
}
