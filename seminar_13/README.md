# Базовые консольные команды


**Если что-то зависло** (моргает курсором, не печатает название юзера в начале строки и не реагирует на то, что вы пишете), прервать можно с помощью **Ctrl+C**. 

Если не сработало, то можно еще Ctrl+Z. Это вернет вам доступ к консоли, но это не сама штатная штука. Если вам пришлось к ней прибегнуть, то почитайте текст после [таблички (2/3)](#inst). Ну или если вам просто интересно.


Будьте внимательны с пробелами. В консоли это важный элемент, который разделяет команды и флаги. **Не ставьте пробелы где попало и не забывайте там, где надо.** С практикой привыкнете, там везде единая логика, а поначалу внимательно смотрите в инструкцию.

За регистром тоже следите, с и С это разные символы.

<a id="nav"></a>

### Навигация (1/3)

|Команда|Описание|
|----------------|:----------------|
| <pre lang="bash"><code>cd \*путь*</code></pre> |переход в другую директорию|
| <pre lang="bash"><code>cd abc</code></pre> |переход в директорию abc, если она находится в текущей директории|
| <pre lang="bash"><code>cd ../</code></pre> |переход на уровень выше|
| <pre lang="bash"><code>cd ../def</code></pre> |переход в директорию def, если она находится на уровень выше|
| <pre lang="bash"><code>cd /mnt/c</code></pre> |переход по абсолютному пути на диск С|
| <pre lang="bash"><code>ls</code></pre> |содержимое текущей директории|
| <pre lang="bash"><code>pwd</code></pre> |путь до текущей директории|
| <pre lang="bash"><code>mkdir</code></pre> |создать директорию|
| <pre lang="bash"><code>mkdir abc</code></pre> |создать директорию abc в текущей папке|
| <pre lang="bash"><code>mkdir ../def</code></pre> |создать директорию def в папке на уровень выше|
| <pre lang="bash"><code>rm</code></pre> |удаление|
| <pre lang="bash"><code>rm 1.txt</code></pre> |удалить файл 1.txt|
| <pre lang="bash"><code>rm -rf abc</code></pre> |удалить папку abc из текущей директории|
| <pre lang="bash"><code>rm *.txt</code></pre> |удалить из текущей папки все файлы с расширением .txt|


<a id="inst"></a>

### Установка и запуск пакетов (2/3)

|Команда|Описание|
|----------------|:----------------|
| <pre lang="bash"><code>sudo apt update</code></pre> |обновление списка пакетов <br> <br> *если у вас свежеустановленный линукс, эту команду надо сделать перед установкой каких-либо пакетов*|
| <pre lang="bash"><code>sudo apt install vim</code></pre> |установка пакета: <br> <br> <blockquote>  sudo - админский доступ <br> apt - пакетный менеджер <br> install - команда менеджеру, чтобы устанавливал <br> vim - название пакета </blockquote> <br>  *если вы пытаетесь установить пакет, а там хз чет какие-то ошибки:* <br> <br> <blockquote> *0) вначале прочитайте зеленую надпись выше* <br> *1) потом проверьте название пакета, пробелы и большие/маленькие буквы* <br> *2) и правда хз, зовите/ищите препа*|
| <pre lang="bash"><code>vim 1.cpp</code></pre> | консольный текстовый редактор **(не для слабаков)**|
| <pre lang="bash"><code>atom 1.cpp</code></pre> | еще один консольный текстовый редактор|
| <pre lang="bash"><code>htop</code></pre> | диспетчер задач|
| <pre lang="bash"><code>cowsay hey kettle</code></pre> | говорящая корова|
| <pre lang="bash"><code>cowsay -h </code></pre> <pre lang="bash"><code> cowsay --help </code></pre> <pre lang="bash"><code> man cowsay </code></pre> | разные способы вызвать встроенную в пакет справку <br> (это два дефиса, помните про внимание к пробелам)|


<a id="comp"></a>

### Компиляция и запуск (3/3)

|Команда|Описание|
|----------------|:----------------|
| <pre lang="bash"><code>gcc</code></pre> | компилятор С|
| <pre lang="bash"><code>g++</code></pre> | компилятор С++ <br> (скорее всего придется поставить через apt)|
| <pre lang="bash"><code>g++ 1.cpp</code></pre> | скомпилировать файл 1.cpp, получившийся исполняемый файл будет называться a.out|
| <pre lang="bash"><code>g++ 1.cpp -o 1</code></pre> | скомпилировать файл 1.cpp, получившийся исполняемый файл будет называться 1|
| <pre lang="bash"><code>./a.out</code></pre> | запустить исполняемый файл a.out из текущей директории|
| <pre lang="bash"><code>./1</code></pre> | запустить исполняемый файл 1 из текущей директории|
| <pre lang="bash"><code>valgrind ./1</code></pre> | запустить исполняемый файл 1 из текущей директории под валгриндом|

<a id="git"></a>

# git

Вот [тут](https://github.com/cyberspacedk/Git-commands#%D0%BA%D0%BE%D0%BD%D1%81%D0%BE%D0%BB%D1%8C%D0%BD%D1%8B%D0%B5-%D0%BA%D0%BE%D0%BC%D0%B0%D0%BD%D0%B4%D1%8B)
база по git, да еще и на русском. Используйте как справку. Нужные команды со всеми флагами и примерами применения можно 
сразу искать там, в табличку ниже вынесены основные команды, которые и понадобятся в данной лабе. (Не являются пошаговой интсрукцией, задание по лабе см. под табличками)

|Команда|Описание|
|----------------|:----------------|
| <pre lang="bash"><code>git clone \*адрес вашего репозитория*</code></pre> | Клонировать удаленный репозиторий в одноименную директорию |
| <pre lang="bash"><code>git pull</code></pre> | Забрать изменения с удаленного репозитория и влить в локальный |
| <pre lang="bash"><code>git fetch</code></pre><pre lang="bash"><code>git merge</code></pre> | То же, что и предыдущий, но отдельными этапами: <br> Первая команда — забрать изменения с удаленного репозитория <br> Вторая — влить изменения в локальный репозиторий |
| <pre lang="bash"><code>git remote add upstream \*наш cowsay*</code></pre> | Добавить оригинальный репозиторий как upstream |
| <pre lang="bash"><code>git fetch upstream</code></pre> | Стягиваем все ветки мастер-репозитория, но пока не сливаем со своими |
| <pre lang="bash"><code>git checkout master</code></pre> | Переключаемся на ветку master своего репозитория |
| <pre lang="bash"><code>git merge upstream/master</code></pre> | Вливаем стянутую ветку master удалённого репозитория upstream в свою ветку master |
| <pre lang="bash"><code>git add text.txt</code></pre> | Добавить в индекс указанный файл (был изменён, был удалён или это новый файл) |
| <pre lang="bash"><code>git commit -m "Name of commit"</code></pre> | Зафиксировать в коммите проиндексированные изменения (закоммитить), добавить сообщение |
| <pre lang="bash"><code>git push</code></pre> | Загрузить новые коммиты из локального репозитория на удаленный |

<a id="gpp"></a>

# Этапы сборки на примере g++

|Код|Описание|
|----------------|:----------------|
| <pre lang="bash"><code>g++ 1.cpp -o 1</code></pre> | Все этапы сразу, обычно так и делают |
| <pre lang="bash"><code>g++ 1.cpp -E -o 11.cpp</code></pre> | Препроцессинг файла 1.cpp, получившийся файл будет называться 11.cpp |
| <pre lang="bash"><code>g++ 11.cpp -c -o 1.o</code></pre> | Компиляция файла 11.cpp, получившийся бинарный файл будет называться 1.о <br>*Здесь можно влезть в ассемблерный листинг, но пока что он вам мало что скажет. Сейчас главное – понять, что именно на этом этапе «читаемый» код на плюсах превращается в «нечитаемый» машинный.* |
| <pre lang="bash"><code>g++ 1.o -o 1</code></pre> | Линковка файла 1.о, получившийся исполняемый файл будет называться 1 |
| <pre lang="bash"><code>./1</code></pre> | Запустить исполняемый файл 1 из текущей директории |
| <pre lang="bash"><code>valgrind ./1</code></pre> | Запустить исполняемый файл 1 из текущей директории под валгриндом |
| <pre lang="bash"><code>g++ 1.o 2.o -o 12</code></pre> | Линковка файлов 1.о и 2.о, получившийся исполняемый файл будет называться 12 |
| <pre lang="bash"><code>g++ 1.cpp 2.cpp -o 12</code></pre> | Все этапы сразу для двух файлов, получившийся исполняемый файл будет называться 12 |
| <pre lang="bash"><code>g++ \*.cpp -o all</code></pre> | Все этапы для всех файлов с расширением срр в текущей директории, получившийся исполняемый файл будет называться all |

<a id="clone"></a>
