#include <iostream>
#include <omp.h>
#include <unistd.h>

// Тут пример следующий:
// Итерации в цикле распределены 
// неравномерно по загрузке 

// Поток 0 берет четные итерации
// Поток 1 берет нечетные итерации

// И так вышло, что нечетные итерации 
// сильно сложнее четных

int main() {
    int N = 10;
 #pragma omp parallel for private(N) num_threads(2) schedule(static, 1)
    for (int i = 0; i < 10; ++i) {
        int rank = omp_get_thread_num();
        N = i % 2;
        sleep(N);
#pragma omp critical
        std::cout << "Rank :" << rank << " Value N: " << N << std::endl;
    }
}

// Если мы каким-либо образом не "распределяем"
// оставщуюся работу между потоками, то это беда
//
// В данном случае программа работает как последовательная,
// потому что поток 0 быстро справился, 
// а поток 1 жестко тужится с работой

// Эту проблему решате концепция thread pool
