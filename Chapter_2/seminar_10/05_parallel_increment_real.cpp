#include <iostream>

// То, что мы увидели,
// называется разделяемая память
// Два потока одновременно записывают
// и читают переменную из одного и того
// же места. Поэтому и получаются
// такие различия: потоки работают
// в недетерминированном "порядке"

int main() {
    int value = 0;
    int N = 1e6;

#pragma omp parallel for
    for (int i = 0; i < 16; i++) {
        // some stuff
        std::cout << i << "\n";
        // Проблема лечится установлением 
        // "критической секции"

        // Как только потом доходит до
        // критической секции, все остальные потоки
        // не могут в неё зайти
        #pragma omp critical
        {
            value += N / 16;
        }
    }
    std::cout << "Value is " << value << std::endl;
}

// Почему же std::cout хуже, чем 
// printf в смысле многопоточности?
