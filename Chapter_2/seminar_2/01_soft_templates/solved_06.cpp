// Было 

void sort(int * arr, int n);

// Стало 1

template<typename T>
void sort(T * arr, int n);

// А теперь можно убрать размер массива, и просто передать указатель на последний элемент

// Стало 2

template<typename T>
void sort(T* begin, T* end);

// В реализации мы используем где-то сравнение вида pointer[i] < pointer[i+1]
// Это можно обобщить как compare(pointer[i], pointer[i+1])
// compare -- это какая-то функция. Давайте её тоже зашаблоним

// Стало 3

template<typename T, typename Compare>
void sort(T* begin, T* end, Compare comparator);

// И вот это есть сигнатура функции сортировки из 
// стандартной библиотеки (std::sort).

// Давайте компаратор тоже напишем шаблонным
// Тогда у нас возникает проблема с тем, что мы не можем
// написать общий случай для всех типов сразу
// Для строк, а уж тем более для MyClass придется писать 
// какие-то специальные функции сравнения

// Так и появляется СПЕЦИАЛИЗАЦИЯ шаблона
