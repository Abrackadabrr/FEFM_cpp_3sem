#include <iostream>

// Шаблоны -- это не совсем классы или функции, а их чертежи
// Во время компиляции обычных функций имена внутри них разрешаются сразу

const int a = 1;

int foo(int x) {
    return a;
    // а -- это имя, которое будет связано с переменной выше, в тот момент,
    // когда компилятор будет компилировать функцию
}

int bar(int x) {
    // return b;
    // Здесь b -- это такое имя, которое не будет связно ни с чем 
    // В результате мы получим ошибку компиляции
}

// В функциях foo и bar все понятно и просто: при компиляции имя либо можно
// связать с какой-нибудь сущностью (функция, переменная и т.д.), либо нет
// потому что это имя нигде не объявлено

// Смотрим на шаблоны

struct special_type {
    static const int value = 1;
};

template<typename T>
int templated() {
    return T::value;
}

int main() {
    return templated<special_type>();
}


// В функции templated имя value зависит от параметра шаблона (то есть от T)
// Из-за этого зависимые имена раскрываются после подстановки шаблонного параметра
// Это принято называть двухвазным разрешением имён
// 1) разрешаются независимые имена (семантические не зависящие от типа)
// 2) разрешаются зависимые именя (семантически зависящие от типа)
