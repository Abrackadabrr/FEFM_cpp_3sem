# Любой Makefile состоит из набора правил
# Каждое правило представляет собой:
#
#	* Цель - 	имя файла (но не всегда, например, абстрактные цели),
#			которое генерируется при выполнении цели
#
#	* Пререквезит - файл или файлы, которые будут использованы для порождения цели
#	* Команды -	 то, что нужно сделать
#
# Команды должны быть отделены табом!
# Типичная схема правила:
#
# Цель: Пререквезит
#	Комадна1
#	Команда2
#	
# Запуск исполнения Makefile можно выполнить так:
# make
# В этом случае в папке будет проивзеден поиск файлов с именами Makefile, makefile или GNUmakefile
# 
# Как make считывает файл?
# make начинает считывать файл с начала. Первая цель, которая попалась на
# его пути является главной целью. Эта цель и будет исполнена, если не указано иное.
# Далее, если главная цель зависит от других целей (эти цели указаны как пререквезиты),
# то make постарается их найти и исполнить ( и так по рекурсии)
# Абстрактные цели начинаются с кодового слова .PHONY. АЦ позволяют избежать конфликтов с названием файлов.

# Также можно запустить команду c флагом -i. Тогда ошибки в исполнении отдельнычх строк будут игнорироваться и не будут прерывать исполнение make

# Теперь обратимся к подключению других файлов make
# Другие файлы make могут быть подключены при помощи команды inlude
#
# inlclude MakefilePath
#
# Если путь к файлу указан, начиная НЕ с /, то make будет искать файл в:
#
#	* текущей папке
#	* папке, которая была указана с флагом -I в командной строке (смотри флаги gcc/g++)
#	* папке, которая была указана с флагом --include_dir
#	* некоторых папках системы
#
#
# Когда подключается другой Makefile, то обработка текущего файла прекращается и начинается
# обработка подключенного

# Переменные можно использовать для хранения имен файлов
# В языке make переменные принято именовать с большими буквами.
# Присвоение переменной какого-то значения делается так:
#
#	VAR = something
#
# Взятие значения переменной выполнятся черех ${}:
#
#	VAR1 = ${VAR}
#
# Цели в Makefile также могут быть шаблонные, то есть содержать в себе специальные обозначения, которые будут заменены на этапе исполнения Makefile

// --- Пример --- //

SOURCES = one.cpp two.cpp three.cpp
$(info ${SOURCES})  # вывели на экран значение переменной SOURCES
OBJECTS=$(SOURCES:.cpp=.o)  # заменили все вхождения .cpp в SOURCES на .o

main: ${OBJECTS}
	g++ -o main main.cpp ${OBJECTS}

%.o: %.cpp
	g++ -c $< -o $@
	
.PHONY: clean
clean:
	rm ${OBJECTS} main || true

# Лобой файл, который удовлетворяет %.cpp (% - произвольная строка, называемая основой) будет являться
# переквизитом. Файл %.o будет являться целью.
# Здесь использованы так называемые автоматические параменные. Вои их список:
#
#	1) $@ - Имя файла цели правила
#	2) $< - Имя первого переквизита
#	3) $? - Имена все переквизитов
#	4) $* - Основа - то, что было выбрано вместо %

