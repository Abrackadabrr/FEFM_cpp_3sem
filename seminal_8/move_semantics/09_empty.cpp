class Empty {

	public:
	Empty() {  
        // default-инициализая полей по конструктору
    }

	// копирующий консруктор
	Empty(const Empty &rhs) { 
        /* 
           побитовое копирование для встроенных типов, 
           
           вызов копирующего конструктора для пользовательских типов.  
        */ 
    } 
	
	~Empty() { 
        /* рекурсивный вызов деструкторов полей */ 
    }
	
	// assingment operator
	Empty& operator=(const Empty &rhs) {
        /* 
           побитовое копирование для встроенных типов, 
           
           вызов оператора присваивания  для пользовательских типов.  
        */
    }

    // также компилятор генерирует нам две move операции 
    Empty(Empty&&) {
        /*
            побитовое копирование для встроенных типов

            вызов move конструктора для пользовательских типов,
            если его, то вызов конструктора копирования
        */
    }

    Empty& operator=(Empty&&) {
        /*
            побитовое копирование для встроенных типов

            вызов move оператора присваивания для пользовательских типов,
            если его нет, то вызов обычного оператора присваивания
        */
    }
};

// Один нюанс про автоматическое определение: 

// Есть есть хоть один определенный из {копируюищй конструктор, оператор присваивания}, 
// то move операции НЕ генерируются,
// и обратно:
// если определено что-то из move операций, то копируюищй конструктор 
// и оператор присваивания не генерируются.

// "Правило пяти":

// Если в вашем типе нетривиально определен (то есть написа руками) один метод из списка:

// конструктор копирования
// оператор присваивания
// деструктор
// move копирования
// move присваивание

// то вам нужно определить их ВСЕ.